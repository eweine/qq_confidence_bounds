{
    "collab_server" : "",
    "contents" : "#' Check Validity of Two-Sided Bounds\n#'\n#' Given bounds for a two sided test, this checks that none of\n#' the bounds fall outside of [0, 1] and that all upper bounds\n#' are greater than the corresponding lower bounds.\n#' This also ensures the the length of the bounds are the same.\n#' This not meant to be called by the user.\n#'\n#' @param lower_bounds Numeric vector where the ith component is the lower bound\n#' for the ith order statistic.\n#' @param upper_bounds Numeric vector where the ith component is the lower bound\n#' for the ith order statistic.\n#'\n#' @return None\n#'\n#' @examples\n#' check_bounds_two_sided(lower_bounds = c(.1, .5), upper_bounds = c(.2, .6))\ncheck_bounds_two_sided <- function(lower_bounds,\n                                   upper_bounds) {\n\n  if(any(lower_bounds > 1) || any(lower_bounds < 0)) {\n\n    stop(\"Not all lower bounds between 0 and 1\")\n\n  }\n\n  if(any(upper_bounds > 1) || any(upper_bounds < 0)) {\n\n    stop(\"Not all upper bounds between 0 and 1\")\n\n  }\n\n  if(any(upper_bounds - lower_bounds < 0)) {\n\n    stop(\"Not all upper bounds are greater than their corresponding lower bounds\")\n\n  }\n\n  if(length(lower_bounds) != length(upper_bounds)) {\n\n    stop(\"The length of the bounds differ\")\n\n  }\n\n}\n\n\n#' Monte Carlo Simulation for Two-Sided Test\n#'\n#' Given bounds for a two sided test on uniform order statistics, this computes\n#' the Type I Error Rate \\eqn{\\alpha} using simulations.\n#'\n#' @param lower_bounds Numeric vector where the ith component is the lower bound\n#' for the ith order statistic. The values must be in ascending order.\n#' @param upper_bounds Numeric vector where the ith component is the lower bound\n#' for the ith order statistic. The values must be in ascending order and\n#' the ith component must be larger than the ith component of the lower bounds.\n#' @param num_sims (Optional) Number of simulations to be run, 1 Million by default.\n#'\n#' @return Type I Error Rate \\eqn{\\alpha}\n#'\n#' @examples\n#' monte_carlo_two_sided(lower_bounds = c(.1, .5), upper_bounds = c(.2, .6))\nmonte_carlo_two_sided <- function(lower_bounds,\n                                  upper_bounds,\n                                  num_sims = 1000000) {\n\n  check_bounds_two_sided(lower_bounds, upper_bounds)\n  n <- length(lower_bounds)\n\n  num_in_ci <- 0 # tracks how many sims have all points in the confidence intervals\n\n  for(iter in seq(from = 1, to = num_sims, by = 1)) {\n\n    # generate uniform RVs\n    iter_rvs <- runif(n)\n    # sort them\n    iter_order_stats <- sort(iter_rvs)\n\n    if (all(iter_order_stats > lower_bounds) && all(iter_order_stats < upper_bounds)) {\n\n      num_in_ci <- num_in_ci + 1\n\n    }\n\n  }\n\n  alpha <- 1 - (num_in_ci / num_sims)\n  return(alpha)\n\n}\n\n#' Calculates Type I Error Rate From Two-Sided Bounds\n#'\n#' Given bounds for a two sided test on uniform order statistics, this computes\n#' the Type I Error Rate \\eqn{\\alpha} using an exact calculation.\n#'\n#' @param lower_bounds Numeric vector where the ith component is the lower bound\n#' for the ith order statistic. The values must be in ascending order.\n#' @param upper_bounds Numeric vector where the ith component is the lower bound\n#' for the ith order statistic. The values must be in ascending order and\n#' the ith component must be larger than the ith component of the lower bounds.\n#'\n#' @return Type I Error Rate \\eqn{\\alpha}\n#'\n#' @examples\n#' get_level_from_bounds_twosided(lower_bounds = c(.1, .5), upper_bounds = c(.6, .9))\n#'\n#' @useDynLib qqconf jointlevel_twosided\n#'\n#' @export\nget_level_from_bounds_two_sided <- function(lower_bounds,\n                                           upper_bounds) {\n\n  check_bounds_two_sided(lower_bounds, upper_bounds)\n  n <- length(lower_bounds)\n  b_vec <- c(lower_bounds, upper_bounds)\n  h_g_df <- data.frame(b = b_vec, h_or_g = c(rep(0, n), rep(1, n)))\n  h_g_df <- dplyr::arrange(h_g_df, b)\n  b_vec <- h_g_df$b\n  bound_id <- h_g_df$h_or_g\n  out <- 0.0\n  # Below, a C routine is called for speed.\n  res <- .C(\"jointlevel_twosided\", b_vec = as.double(b_vec),\n            bound_id = as.integer(bound_id), num_points = as.integer(n),\n            out = as.double(out))\n  return(res$out)\n\n}\n\n#' Calculates Local Bounds For Two-Sided Test\n#'\n#' Given the size of the dataset and the desired Type I Error rate \\eqn{\\alpha},\n#' this calculates two-sided testing bounds for each order statistic.\n#' These bounds are created using \"equal local levels,\" which means that\n#' each bound pair corresponds to a test that has a Type I Error rate of \\eqn{\\eta}\n#' on its corresponding order statistic.\n#'\n#' @param alpha Desired Type I Error rate of the complete test.\n#' @param n Size of the dataset.\n#' @param tol (Optional) Relative tolerance of the \\eqn{\\alpha} level of the\n#' simultaneous test. Defaults to 1e-8.\n#' @param max_it (Optional) Maximum number of iterations of Binary Search Algorithm\n#' used to find the bounds. Defaults to 100 which should be much larger than necessary\n#' for a reasonable tolerance.\n#'\n#' @return A list with components\n#' \\itemize{\n#'   \\item lower_bound - Numeric vector containing the lower bounds of the test of each order statistic.\n#'   \\item upper_bound - Numeric vector containing the upper bounds of the test of each order statistic.\n#'   \\item x - Expectation of each order statistic. This is the x-axis for the bounds if used in a qq-plot.\n#'   \\item local_level - Type I Error rate of each individual test on the order statistic. It is equal for all tests.\n#' }\n#'\n#' @examples\n#' get_level_from_bounds_twosided(alpha = .05, n = 100, tol = 1e-6, max_it = 50)\n#'\n#' @export\nget_bounds_two_sided <- function(alpha,\n                                n,\n                                tol = 1e-8,\n                                max_it = 100) {\n\n  # Note, I'll probably add something here that allows the user to choose either\n  # an approximate method or an exact method that looks between the different local levels.\n  eta_high <- -log(1 - alpha) / (2 * log(log(n)) * log(n)) # this is the asymptotic level of eta\n  eta_low <- alpha / n\n  eta_curr <- eta_low + (eta_high - eta_low) / 2\n  n_it <- 0\n\n  while (n_it < max_it) {\n\n    n_it <- n_it + 1\n    h_vals <- qbeta(eta_curr / 2, 1:n, n:1)\n    g_vals <- qbeta(1 - (eta_curr / 2), 1:n, n:1)\n    test_alpha <- 1 - get_level_from_bounds_two_sided(h_vals, g_vals)\n\n    if (abs(test_alpha - alpha) / alpha <= tol) break\n\n    if (test_alpha > alpha) {\n\n      eta_high <- eta_curr\n      eta_curr <- eta_curr - (eta_curr - eta_low) / 2\n\n    } else if (test_alpha < alpha) {\n\n      eta_low <- eta_curr\n      eta_curr <- eta_curr + (eta_high - eta_curr) / 2\n\n    }\n\n  }\n\n  if(n_it == max_it) {\n\n    warning(\"Maximum number of iterations reached.\")\n\n  }\n\n  alpha_vec <- seq(from = 1, to = n, by = 1)\n  beta_vec <- n - alpha_vec + 1\n  order_stats_mean <- alpha_vec / (alpha_vec + beta_vec)\n\n  return(list(lower_bound = h_vals,\n              upper_bound = g_vals,\n              x = order_stats_mean,\n              local_level = eta_curr))\n\n}\n",
    "created" : 1561571193380.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "200976813",
    "id" : "56CBBF16",
    "lastKnownWriteTime" : 1561049849,
    "last_content_update" : 1561049849,
    "path" : "~/Documents/thesis/qqconf/R/two_sided.R",
    "project_path" : "R/two_sided.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}