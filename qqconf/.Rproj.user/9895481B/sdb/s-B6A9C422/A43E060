{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Untitled\"\nauthor: \"Eric Weine\"\ndate: \"June 6, 2019\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n```{r}\nlibrary(dplyr)\n```\n\n\n```{r}\n# num_ppl is the number of samples\n# num_genes is the number of genes in the model\n# prop_true is the proportion of true signals\n# true_var is the variance of signals \n#noise_var is the general noise variance\nsim_from_genetic_model <- function(num_ppl, num_genes, prop_true, true_eff, noise_var) {\n  \n  # First, simulate from the signals\n  signal_vec <- numeric(num_genes)\n  for(i in seq(from = 1, to = num_genes, by = 1)) {\n    \n    if(runif(1) < prop_true) {\n      \n      signal_vec[i] <- true_eff\n      \n    } else {\n      \n      signal_vec[i] <- 0\n      \n    }\n    \n  }\n  \n  # now, for each individual I can just take the dot product of the signal and their genes\n  # then I just need to have noise, and I have the outcome\n  # I'm not sure what type of genetic model we're assuming for the individuals\n  # that probably doesn't matter however\n  G_mat <- matrix(data = rep(0, (num_ppl * num_genes)), nrow = num_ppl, ncol = num_genes)\n  Y_vec <- numeric(num_ppl)\n  for(i in seq(from = 1, to = num_genes, by = 1)) {\n    \n    G_mat[,i] <- rbinom(n = num_ppl, size = 2, prob = .3) # can potentially change this, not sure it matters\n    \n  }\n  \n  for(i in seq(from = 1, to = num_ppl, by = 1)) {\n    \n    Y_vec[i] <- (G_mat[i,] %*% signal_vec) + rnorm(n = 1, mean = 0, sd = sqrt(noise_var))\n    \n  }\n  \n  return(list(Y = Y_vec, G = G_mat))\n  \n}\n```\n\nI should work on a faster version of the code above otherwise this will take a very long time to iterate through.\n\n```{r}\nsim_from_genetic_model <- function(num_ppl, num_genes, prop_true, true_var, noise_var) {\n  \n  # First, simulate from the signals\n  true_vec <- rnorm(n = num_genes, mean = 0, sd = true_var)\n  sigs <- runif(n = num_genes)\n  sig_true <- as.numeric(sigs <= prop_true)\n  signal_vec <- true_vec * sig_true\n  \n  total_data <- rbinom(n = num_ppl * num_genes, size = 2, prob = .3)\n  G_mat <- matrix(data = total_data, nrow = num_ppl, ncol = num_genes)\n  signal_col <- matrix(data = signal_vec, ncol = 1)\n  \n  Y_vec <- G_mat %*% signal_col + rnorm(n = num_ppl, mean = 0, sd = sqrt(noise_var))\n  \n  \n  return(list(Y = Y_vec, G = G_mat))\n  \n}\n```\n\n\nNow that I have this, I should be able to simulate data from the model and then get p-values for each of the genes and then I can make a qqplot.\n\n```{r}\n# First, want to test the code to make sure that it actually works\nout <- sim_from_genetic_model(num_ppl = 1000, num_genes = 500000, .1, .3, 1)\np_t_test_vec <- numeric(500000)\ny <- out$Y\nfor(i in seq(from = 1, to = 500000)) {\n  \n  x <- out$G[,i]\n  gene_lm <- lm(y ~ x)\n  p_t_test_vec[i] <- summary(gene_lm)[[\"coefficients\"]][\"x\", \"Pr(>|t|)\"]\n  \n}\n```\n\nNow, I have to experiment with this and start to graph the bounds. I can put this on a different scale later, but for now I'll just worry about if everything falls inside of the bounds or not. \n\n```{r}\nbounds <- get_bounds_two_sided(alpha = .05, n = 500000)\nbounds_df <- as.data.frame(bounds)\nbounds_df <- bounds_df %>% mutate(p_val = p_t_test_vec)\n```\nThis is all fine, but the issue is that the bounds have to be for 500000, which is not currently available given the computational resources. I'll come back to this once I work out the pre-computation.\n",
    "created" : 1559877925453.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4160909174",
    "id" : "A43E060",
    "lastKnownWriteTime" : 1561499041,
    "last_content_update" : 1561499041346,
    "path" : "~/Documents/genetic_simulation_thesis_code.Rmd",
    "project_path" : null,
    "properties" : {
        "last_setup_crc32" : ""
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}